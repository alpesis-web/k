<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | K]]></title>
  <link href="http://k.arttechresearch.com/categories/tech/atom.xml" rel="self"/>
  <link href="http://k.arttechresearch.com/"/>
  <updated>2016-02-20T21:17:37+08:00</updated>
  <id>http://k.arttechresearch.com/</id>
  <author>
    <name><![CDATA[K]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Installing ROS on Ubuntu]]></title>
    <link href="http://k.arttechresearch.com/tech/2016/02/20/installing-ros-on-ubuntu/"/>
    <updated>2016-02-20T21:04:48+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2016/02/20/installing-ros-on-ubuntu</id>
    <content type="html"><![CDATA[<h2>Requirement</h2>

<ul>
<li>Ubuntu 14.04</li>
</ul>


<h2>ROS</h2>

<h3>Installation</h3>

<pre><code class="bash">$ sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list'
$ sudo apt-key adv --keyserver hkp://pool.sks-keyservers.net:80 --recv-key 0xB01FA116
$ sudo apt-get update

$ sudo apt-get install ros-jade-desktop-full
</code></pre>

<h3>Configuration</h3>

<pre><code class="bash">$ sudo rosdep init
$ rosdep update

$ echo "source /opt/ros/jade/setup.bash" &gt;&gt; ~/.bashrc
$ source ~/.bashrc
</code></pre>

<h3>Additional Tools</h3>

<pre><code class="bash">$ sudo apt-get install python-rosinstall
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Design Patterns in Python]]></title>
    <link href="http://k.arttechresearch.com/tech/2016/02/16/design-patterns-in-python/"/>
    <updated>2016-02-16T00:16:49+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2016/02/16/design-patterns-in-python</id>
    <content type="html"><![CDATA[<p>Study notes on <a href="http://www.amazon.com/Python-Practice-Concurrency-Libraries-Developers/dp/0321905636">Python in Practice: Create Better Programs Using Concurrency, Libraries, and Patterns</a></p>

<ul>
<li>Creational design patterns</li>
<li>Structural design patterns</li>
<li>Behavioral design patterns</li>
</ul>


<p>Comparisons:</p>

<ul>
<li>Creational design patterns concern on how objects are created;</li>
<li>Structural design patterns concern on how objects are composed together to form new and larger objects;</li>
<li>Behavioral design patterns concern on how individual objects or groups of objects can get things done.</li>
</ul>


<h2>1. Creational Design Patterns</h2>

<p>Creational design patterns are concerned with how objects are created. When we concern
on how objects are created, the creational design patterns are useful.</p>

<h3>1.1. Abstract factory</h3>

<p>The abstract facroty pattern is designed for situations where we want to create complex
objects that are composed of other objects and where the composed objects are all of one
particular &ldquo;family&rdquo;.</p>

<pre><code class="python DiagramFactory">class DiagramFactory:

    @classmethod
    def make_diagram(self, width, height):
        pass

    @classmethod
    def make_rectangle(self, x, y, width, height, fill="white"):
        pass

    @classmethod
    def make_text(self, x, y, text, fontsize=12):
        pass


class SvgDiagramFactory(DiagramFactory):

    class Text:
        def __init__(self):
            pass

    def make_diagram(self, width, height):
        return SvgDiagram(width, height)

class SvgDiagram:

    def add(self, component):
        pass


def create_diagram(factory):
    ...
    return diagram


if __name__ == '__main__':
    txtDiagram = create_diagram(DiagramFactory())
    svgDiagram = create_diagram(SvgDiagramFactory())
</code></pre>

<h3>1.2. Builder</h3>

<p>The builder pattern is similar to the abstract factory pattern in that both patterns
are designed for creating complex objects that are composed of other objects.
But builder pattern also holds the representation of the entire complex object itself.</p>

<p>The differences between abstract factory and builder are
- factory is the subclass: Car -> Honda/Ford
- builder implements the whole parts: Card -> Honda()/Ford() with custom updates</p>

<pre><code class="python FormBuilder">
class AbstractFormBuilder(metaclass=abc.ABCMeta):

    @abc.abstractmethod
    def add_title(self, title):
        pass

    @abc.abstractmethod
    def form(self):
        pass

    @abc.abstractmethod
    def add_label(self, text, row, column, **kwargs):
        pass

class HtmlFormBuilder(AbstractFormBuilder):

    def __init__(self):
        pass

    def add_title(self, title):
        pass

    def add_label(self, text, row, column, **kwargs):
        pass

    def add_entry(self, variable, row, column, **kwargs):
        pass

    def form(self):
        pass

class TkFormBuilder(AbstractFormBuilder):

    def __init__(self):
        pass

    def add_title(self, title):
        pass

    def add_label(self, text, row, column, **kwargs):
        pass

    def form(self):
        pass

def create_login_form(builder):
    ...
    return builder


if __name__ == '__main__':
    htmlForm = create_login_form(HtmlFormBuilder())
    tkForm = create_logiin_form(TkFormBuilder())
</code></pre>

<h3>1.3. Factory method</h3>

<p>The factory method pattern is intended to be used when we want subclasses to choose
which classes they should instantiate when an object is requested. This is useful in its
own right, but can be taken further and used in cases where we cannot know the class in
advance (e.g. the class to use is based on what we read from a file or depends on user
input).</p>

<pre><code class="python Factory method">
BLACK, WHITE = ("BLACK", "WHITE")

class AbstractBoard:

    def __init__(self, rows, columns):
        self.board = [[None for _ in range(columns) for _ in range(rows)]]
        self.populate_board()

    def populate_board(self):
        raise NotImplementedError()

    def __str__(self):
        squares = []
        for y, row in enumerate(self.board):
            for x, piece in enumerate(row):
                square = console(piece, BLACK if (y+x) %s else WHITE)
            squares.append("\n")
        return "".join(squares)

class CheckersBoard(AbstractBoard):

    def __init__(self):
        super().__init__(10,10)

    def populate_board(self):
        for x in range(0, 9, 2):
            for row in range(4):
                column = x + ((row + 1) % 2)
                self.board[row][column] = BlackDraught()
                self.board[row+6][column] = WhiteDraught()

class ChessBoard(AbstractBoard):

    def __init__(self):
        super().__init__(8, 8)

    def populate_board(self):
        self.board[0][0] = BlackChessRook()
        self.board[0][1] = BlackChessKnight()
        ...
        self.board[7][7] = WhiteChessRook()
        for column in range(8):
            self.board[1][column] = BlackChessPawn()
            self.board[6][column] = WhiteChessPawn()

class Piece(str):

    __slots__ = ()

ckass BlackDraught(Piece):

    __slots__ = ()

    def __new__(Class):
        return super().__new__(Class, "\N(black draughts man)")

class WhiteChessKing(Piece):

    __slots__ = ()

    def __new__(Class):
        return super().__new__(Class, "\N(white chess king)")

if __name__ == '__main__':

    checkers = CheckersBoard()
    chess = ChessBoard()
</code></pre>

<h3>1.4. Prototype</h3>

<p>The prototype pattern is used to create new objects by cloning an original object,
and then modifying the clone.</p>

<pre><code class="python Prototype">class Point:

    __slots__ = ("x", "y")

    def __init__(self, x, y):
        self.x = x
        self.y = y

def make_object(Class, *args, **kwargs):
    return Class(*args, **kwargs)


if __name__ == '__main__':

    point1 = Point(1, 2)
    point2 = eval("{}({}, {}))".format("Point", 2, 4))
    point3 = getattr(sys.modules[__name__], "Point")(3,6)
    point4 = globals()["Point"](4, 8)
    point5 = make_object(Point, 5, 10)
    point6 = copy.deepcopy(point5)
    point6.x = 6
    point6.y = 12
    point7 = point1.__class__(7, 14)
</code></pre>

<h3>1.5. Singleton</h3>

<p>The singleton pattern is used when we need a class that has only a single instance
that is the one and only instance accessed throughtout the program.</p>

<h2>2. Structural Design Patterns</h2>

<p>The primary concern of structural design patterns is how objects are composed together to
form new, larger objects.</p>

<p>Three themes stand out in structural design patterns:</p>

<ul>
<li>adapting interfaces</li>
<li>adding functionality</li>
<li>handling collections of objects</li>
</ul>


<p>Patterns:</p>

<ul>
<li>the adapter and facade patterns make it straightforward to reuse classes in new contexts</li>
<li>the bridge pattern makes it possible to embed the sophisticated functionality of one class inside another</li>
<li>the composite pattern makes it easy to create hierarchies of objects</li>
<li>the flyweight pattern is to use the object reference</li>
</ul>


<h3>2.1. Adapter</h3>

<p>The adapter pattern is a technique for adapting an interface so that one class
can make use of another &ndash; that has an incompatible interface &ndash; without changing either
of the classes being used.</p>

<pre><code class="python Adapter">"""
Page
 --&gt; renderer &lt;---- Renderer Interface
                         |---&gt; TextRenderer
                         |---&gt; HtmlRenderer &lt;---- HtmlWriter (adapter)
"""

class Page:

    def __init__(self, title, renderer):
        pass

    def add_paragraph(self, paragraph):
        pass

    def render(self):
        pass

class Renderer(metaclass=abc.ABCMeta):

    @classmethod
    def __subclasshook__(Class, Subclass):
        pass

class TextRenderer:

    def __init__(self, width=80, file=sys.stdout):
        pass

    def header(self, title):
        pass

    def paragraph(self, text):
        pass

    def footer(self):
        pass

class HtmlRenderer:

    def __init__(self, htmlWriter):
        self.htmlWriter = htmlWriter

    def header(self, title):
        self.htmlWriter.header()
        self.htmlWriter.title(title)
        self.htmlWriter.start_body()

    def paragraph(self, text):
        self.htmlWriter.body(text)

    def footer(self):
        self.htmlWriter.end_body()
        self.htmlWriter.footer()

class HtmlWriter:

    def __init__(self, file=sys.stdout):
        pass

    def header(self):
        pass

    def title(self, title):
        pass

    def start_body(self, text):
        pass

    def body(self, text):
        pass

    def end_body(self):
        pass

    def footer(self):
        pass


if __name__ == '__main__':

    textPage = Page(title, TextRenderer(22))
    textPage.add_paragraph(paragraph1)
    textPage.add_paragraph(paragraph2)
    textPage.render()

    htmlPage = Page(title, HtmlRenderer(HtmlWriter(file)))
    htmlPage.add_paragraph(paragraph1)
    htmlPage.add_paragraph(paragraph2)
    htmlPage.render()
</code></pre>

<h3>2.2. Bridge</h3>

<p>The bridge pattern is used in situations where we want to separate an abstraction
(e.g., an interface or an algorithm from how it is implemented.</p>

<p>The conventional approach without using the bridge pattern would be to create one
or more abstract base classes and then provide two or more concrete implementations
of each of the base classes.</p>

<p>But with the bridge pattern the approach is to create two independent class hierarchies:</p>

<ul>
<li>the &ldquo;abstract&rdquo; one defining the operations (e.g., the interface and high-level algorithms)</li>
<li>the concrete one providing the implementations that the abstract operations will ultimately call.</li>
</ul>


<p>The &ldquo;abstract&rdquo; class aggregates an instance of one of the concrete implementation classes -
and this instance serves as a bridge between the abstract interface and the concrete operations.</p>

<p>Bridge pattern is to pass serveral separated classes into a base class (bridge).</p>

<pre><code class="python Bridge">"""
BarCharter
  |----&gt; renderer  &lt;---- Bar Charter Interface
                               |----&gt; TextBarRenderer
                               |----&gt; ImageBarRenderer
"""

class BarCharter:

    def __init__(self, renderer):
        pass

    def render(self, caption, pairs):
        pass

@Qtrac.has_methods("initialize", "draw_caption", "draw_bar", "finalize")
class BarRenderer(metaclass-abc.ABCMeta): pass

class TextBarRenderer:

    def __init__(self, scaleFactor=40):
        pass

    def initialize(self, bars, maximum):
        pass

    def draw_caption(self, caption):
        pass

    def draw_bar(self, name, value):
        pass

    def finalize(self):
        pass

class ImageBarRenderer:

    COLORS = [Image.color_for_name(name) for name in ("red", "green", "blue")]

    def __init__(self, stepHeight=10, barWidth=30, barGap=2):
        pass

    def initialize(self, bars, maximum):
        pass

    def draw_caption(self, caption):
        pass

    def draw_bar(self, name, value):
        pass

    def finalize(self):
        pass


if __name__ == '__main__':

    pairs = (("Mon", 16), ("Tue", 17), ("Wed", 19))

    textBarCharter = BarCharter(TextBarRenderer())
    imageBarCharter = BarCharter(ImageBarRenderer())
</code></pre>

<h3>2.3. Composite</h3>

<p>The composite pattern is designed to support the uniform treatment of objects
in a hierarchy, whether they contain other objects (as part of the hierarchy) or not.
Such objects are called composite.</p>

<p>In the classic approach, composite objects have the same base class for both individual
objects and for collections of objects. Both composite and noncomposite objects normally
have the same core methods, with composite objects also having additional methods to
support adding, removing, and iterating their child objects.</p>

<p>This pattern is often used in drawing programs, such as Inkscape, to support grouping and
ungrouping. The pattern in such cases because when the user selects components to group
or ungroup, some of the components might be single items (e.g., a rectangle), while
others might be composite (e.g., a face made up of many different shapes).</p>

<pre><code class="python Composite">"""
Boxed Pencil Set
  |----&gt; Box
  |----&gt; PencilSet ----&gt; Pencil, Ruler, Eraser
  |----&gt; Pencil

SimpleItem (concrete)
  |----&gt; AbstractItem (abstract)

CompositeItem (concreate)
  |----&gt; AbstractCompositeItem (abstract)
                 |----&gt; AbstractItem (abstract)

"""

class AbstractItem(metaclass=abc.ABCMeta):

    @abc.abstractproperty
    def composite(self):
        pass

    def __iter__(self):
        return iter([])

class SimpleItem(AbstractItem):

    def __init__(self, name, price=0.00):
        pass

    @property
    def composite(self):
        return False

    def print(self, indent="", file=sys.stdout):
        pass

class AbstractCompositeItem(AbstractItem):

    def __init__(self, *items):
        self.children = []
        if items:
            self.add(*items)

    def add(self, first, *items):
        self.children.append(first)
        if items:
            self.children.extend(items)

    def remove(self, item):
        self.children.remove(item)

    def __iter__(self):
        return iter(self.children)

class CompositeItem(AbstractCompositeItem):

    def __init__(self, name, *items):
        super().__init__(*items)
        self.name = name

    @property
    def composite(self):
        return True

    @property
    def price(self):
        return sum(item.price for item in self)

    def print(self, indent="", file=sys.stdout):
        pass


if __name__ == '__main__':

    pencil = SimpleItem("Pencil", 0.40)
    ruler = SimpleItem("Ruler", 1.60)
    eraser = SimpleItem("Eraser", 0.20)
    pencilSet = CompositeItem("Pencil Set", pencil, ruler, eraser)

    box = SimpleItem("Box", 1.00)
    boxedPencilSet = CompositeItem("Boxed Pencil Set", box, pencilSet)
    boxedPencilSet.add(pencil)
</code></pre>

<h3>2.4. Decorator</h3>

<p>A decorator is a function that takes a function as its sole argument and returns a new
function with the same name as the original function but with enhanced functionality.
Decorators are often used by frameworks (e.g., web frameworks) to make it easy to integrate
our own functions within the framework.</p>

<pre><code class="python Decorator">"""
@decorator #3
  @decorator #2
    @decorator #1
      function, method, or class
"""

@float_args_and_return
def mean(first, second, *rest):
   numbers = (first, second) + rest
   return sum(numbers) / len(numbers)

def float_args_and_return(function):
    @functools.wraps(function)
    def wrapper(*args, **kwargs):
        args = [float(arg) for arg in args]
        return float(function(*args, **kwargs))
    return wrapper



@statically_typed(str, str, return_type=str)
def make_tagged(text, tag):
    return "{0}{1}{0}".format(tag, escape(text))

@statically_typed(str, int, str)
def repeat(what, count, separator):
    return ((what + separator) * count)[:-len(separator)]

def statically_typed(*types, return_type=None):
    def decorator(function):
        @functools.wraps(function)
        def wrapper(*args, **kwargs):
            ...
            return result
        return wrapper
    return decorator

#--------------------------------------------------#

@ensure("title", is_non_empty_str)
@ensure("isbn", is_valid_isbn)
@ensure("price", is_in_range(1, 100000))
@ensure("quantity", is_in_range(0, 10000))
class Book:

    def __init__(self, title, isbn, price, quantity):
        pass

    @property
    def value(self):
        return self.price * self.quantity


ensure("title", is_non_empty_str)(
    ensure("isbn", is_valid_isbn)(
      ensure("price", is_in_range(1, 100000))(
          ensure("quantity", is_in_range(0, 10000))(class Book: ...))))

def ensure(name, validate, doc=None):
    def decorator(Class):
        privateName = "__" + name
        def getter(self):
            return getattr(self, privateName)
        def setter(self, value):
            validate(name, value)
            setattr(self, privateName, value)
        setattr(Class, name, property(getter, setter, doc=doc))
        return Class
    return decorator

def is_non_empty_str(name, value):
    pass

def is_in_range(minimum=None, maximum=None):
    pass

#--------------------------------------------------#

@do_ensure
class Book:

    title = Ensure(is_non_empty_str)
    isbn = Ensure(is_valid_isbn)
    price = Ensure(is_in_range(1, 10000))
    quantity = Ensure(is_in_range(0, 10000))

    def __init__(self, title, isbn, price, quantity):
        self.title = title
        self.isbn = isbn
        self.price = price
        self.quantity = quantity

    @property
    def value(self):
        return self.price * self.quantity

class Ensure:

    def __init__(self, validate, doc=None):
        self.validate = validate
        self.doc = doc

def do_ensure(Class):

    def make_property(name, attribute):
        privateName = "__" + name
        def getter(self):
            return getattr(self, privateName)
        def setter(self, value):
            attribute.validate(name, value)
            setattr(self, privatName, value)
        return property(getter, setter, doc=attribute.doc)
    for name, attribute in Class.__dict__.items():
        if isinstance(attribute, Ensure):
            setattr(Class, name, make_property(name, attribute)
    return Class
</code></pre>

<h3>2.5. Facade</h3>

<p>The facade pattern is used to present a simplified and uniform interface to a
subsystem whose interface is too complex or too low-level for convenient use.</p>

<pre><code class="python Facade">
"""
Archive
  |----&gt; filename
  |----&gt; names()
  |----&gt; unpack()  ----&gt; gzip
                   ----&gt; tarfile.TarFile --&gt; getnames()/extractall()
                   ----&gt; zipfile.ZipFile --&gt; namelist()/extractall()
"""

class Archive:

    def __init__(self, filename):
        self._names = None
        self._unpack = None
        self._file = None
        self._filename = filename

    @property
    def filename(self):
        return self.__filename`

    @filename.setter
    def filename(self, name):
        self.close()
        self.__filename = name

    def close(self):
        pass

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()

    def names(self):
        if self._file is None:
            self._prepare()
        return self._names()

    def unpack(self):
        if self._file is None:
            self._prepare()
        return self._unpack()

    def _prepare(self):
        if self.filename.endswith((".tar.gz", ".tar.gz2", "tar.xz", ".zip")):
            self._prepare_tarball_or_zip()
        elif self.filename.endswith(".gz"):
            self._prepare_gzip()
        else:
            raise ValueError("unreadable: {}".format(self.filename))

    def _prepare_tarball_r_zip(self):
        pass

    def _prepare_gzip(self):
        pass
</code></pre>

<h3>2.6. Flyweight</h3>

<p>The flyweight pattern is designed for handling large numbers of relatively small objects,
where many of the small objects are duplicates of each other. The pattern is implemented by
representing each unique object only once, and by sharing this unique instance wherever it
is needed.</p>

<pre><code class="python Flyweight">red, gree, blud = "red", "green", "blue"
x = (red, green, blue, red, green, blue, red, green)
y = ("red", "green", "blue", "red", "green", "blue", "red", "green")

class Point:

    #__slots__ = ("x", "y", "z", "color")
    __slots__ = ()
    __dbm = shelve.open(os.path.join(tempfile.gettempdir(), "point.db"))

    def __init__(self, x=0, y=0, z=0, color=None):
        self.x = x
        self.y = y
        self.z = z
        self.color = color

    def __key(self, name):
        return "{:X}:{}".format(id(self), name)

    def __getattr__(self, name):
        return Point.__dbm(self.__key(name))

    def __setattr__(self, name, value):
        Point.__dbm[self.__key(name)] = value
</code></pre>

<h3>2.7. Proxy</h3>

<p>The proxy pattern is used when we want one object to stand in for another.</p>

<p>Four use cases:</p>

<ul>
<li>a remote proxy where a local object proxies a remote object</li>
<li>a virtual proxy that allows us to create lightweight objects instead of heavyweight objects</li>
<li>a protection proxy that provides different levels of access depending on a client&rsquo;s access rights</li>
<li>a smart reference that &ldquo;performs additional actions where an object accessed&rdquo;</li>
</ul>


<p>Proxy pattern is also be used in unit testing.</p>

<pre><code class="python Proxy">
class ImageProxy:

    def __init__(self, ImageClass, width=None, height=None, filename=None):
        ...
        self.Image = ImageClass

    def load(self, filename):
        self.commands = [(self.Image, None, None, filename)]

class Image:

    def set_pixel(self, x, y, color):
        pass

    def line(self, x0, y0, x1, y1, color):
        pass

    def rectangle(self, x0, y0, x1, y1, outline=None, file=None):
        pass

    def ellipse(self, x0, y0, x1, y1, outline=None, fill=None):
        pass

    def save(self, filename=None):
        pass

if __name__ == '__main__':

    YELLOW, CYAN, BLUE, RED, BLACK = (Image.color_for_name(color)
        for color in ("yellow", "cyan", "blue", "red", "black"))

    image = ImageProxy(Image.Image, 300, 60)
    image.rectangle(0, 0, 299, 59, fill=YELLOW)
    image.ellipse(0, 0, 299, 59,, fill=CYAN)
    image.ellipse(60, 20, 120, 40, BLUE, RED)
    image.line(181, 32, 239, 32, BLUE)
    image.save(filename)
</code></pre>

<h2>3. Behavioral Design Patterns</h2>

<p>The behavioral patterns are concerned with how things get done, that is, with algorithms
and object interactions. They provide powerful ways of thinking about and organizing
computations.</p>

<h3>3.1. Chain of responsibility</h3>

<p>The chain of responsibility pattern is designed to decouple the sender of a request from
the recipient that processes the request.</p>

<p>The first function sends a request to a chain of receivers. The first receiver in the chain
either can handle the request to the next receiver in the chain. The second receiver has the
same choices, and so on, until the last one is reached (which could choose to throw the request
away or to raise an exception).</p>

<pre><code class="python Conventional Chain">"""
Conventional Chain

A generator is a function or method that has one or more yield expressions instead of
returns. Whenever a yield is reached, the value yielded is produced, and the function
or method is suspended with all its state intact. At this point the function has
yielded the processor (to the receiver of the value it has produced), so although
suspended, the function does not block. Then, when the function or method is used again,
execution resumes from the statement following the yield. So, value are pulled from a
generator by iterating over it (e.g., using for value in generator:) or by calling
next() on it.

    &lt;event&gt; -&gt; TimeHandler -&gt; KeyHandler -&gt; MouseHandler -&gt; NullHandler
"""

class NullHandler:

    def __init__(self, successor=None):
        self.__successor = successor

    def handle(self, event):
        if self.__successor is not None:
            self.__successor.handle(event)

class MouseHandler(NullHandler):

    def handle(self, event):
        if event.kind == Event.MOUSE:
            print("Click: {}".format(event))
        else:
            super().handle(event)

class DebugHandler(NullHandler):

    def __init__(self, successor=None, file=sys.stdout):
        super().__init__(successor)
        self.__file = file

    def handle(self, event):
        self.__file.write("*DEBUG*: {}\n".format(event))
        super().handle(event)


if __name__ == '__main__':

    handler1 = TimerHandler(KeyHandler(MouseHandler(NullHandler())))
    handler2 = DebugHandler(handler1)
</code></pre>

<p>Coroutine-based Chain</p>

<p>A coroutine uses the same yield expression as a generator but has different behavior.
A coroutine executes an infinite loop and starts out suspended at its first (or only)
yield expression, waiting for a value to be sent to it. If and when a value is sent,
the coroutine receives this as the value ofo its yield expression. The coroutine can then
do any processing it wants and when it has finished, it loops and again becomes suspended
waiting for a value to arrive at its next yield expression. So, values are pushed into a
coroutine by calling the coroutine&rsquo;s send() and throw() methods.</p>

<pre><code class="python Coroutine-based Chain">
def coroutine(function):
    @functools.wraps(function)
    def wrapper(*args, **kwargs):
        generator = function(*args, **kwargs)
        next(generator)
        return generator
    return wrapper

@coroutine
def key_handler(successor=None):
    while True:
        event = (yield)
        if event.kind == Event.KEYPRESS:
            print("Press: {}".format(event))
        elif successor is not None:
            successor.send(event)

@coroutine
def debug_handler(successor, file=sys.stdout):
    while True:
        event = (yield)
        file.write("*DEBUG*: {}\n".format(event))
        successor.send(event)

if __name__ == '__main__':

    pipeline = key_handler(mouse_handler(timer_handler()))
    pipeline - debug_handler(pipeline)
</code></pre>

<h3>3.2. Command</h3>

<p>The command pattern is used to encapsulate commands as objects. This makes it possible,
for example, to build up a sequence of commands for deferred execution or to create undoable
commands.</p>

<pre><code class="python Command">class Grid:

    def __init__(self, width, height):
        pass

    def cell(self, x, y, color=None):
        pass

    @property
    def rows(self):
        pass

    @property
    def columns(self):
        pass


class UndoableGrid(Grid):

    def create_cell_command(self, x, y, color):
        def undo(self):
            pass

        def do(self):
            pass

        def create_rectangle_macro(self, x0, x0, x1, y1, color):
            pass

class Command:

    def __init__(self, do, undo, description=""):
        pass

    def __call__(self):
        self.do()

class Macro:

    def __init__(self, description=''):
        pass

    def add(self, command):
        pass

    def __call__(self):
        pass

    do = __call__

    def undo(self):
        pass

if __name__ == '__main__':

    grid = UndoableGrid(8, 3)
    redLeft = grid.create_cell_command(2, 1, "red")
    redRight = grid.create_cell_command(5, 0, "red")
    redLeft()
    redRight.do()
</code></pre>

<h3>3.3. Interpreter</h3>

<p>The interpreter pattern formalize two common requirements:</p>

<ul>
<li>providing some means by which users can enter nonstring values into applications</li>
<li>allowing users to program applications</li>
</ul>


<pre><code class="python Interpreter: Expression Evaluataion with eval()/exec()/subprocess">import math

def global_context():
    globaContext = globals().copy()
    for name in dir(math):
        if not name.startswith("_"):
            globalContext[name] = getattr(math, name)
    return globalContext

def calculate(expression, globalContext, localContext, current):
    pass

def update(localContext, result, current):
    pass


if __name__ == '__main__':

    quit = "Ctrl+Z,Enter" if sys.platform.startswith("win") else "Ctrl+D"
    prompt = "Enter an expression ({} to quit): ".format(quit)
    current = types.SimpleNamespace(letter='A')
    globalContext = global_context()
    localContext = collections.OrderedDict()
    while True:
        try:
            expression = input(prompt)
            if expression:
                calculate(expression, globalContext, localContext, current)
        except EOFError:
            print()
            break

#--------------------------------------------------#

def execute(code, context):

    try:
        exec(code.code, globals(), context)
        result = context.gete("result)"
        error = context.get("error")
        handle_result(code, result, error)
    except Exception as err:
        print(err)

if __name__ == '__main__':

    context = dict(genome=genome, target='', replace='')
    execute(code, context)
</code></pre>

<h3>3.4. Iterator</h3>

<p>The iterator pattern provides a way of sequentially accessing the items inside a
collection or an aggregate object without exposing any of the internals of the
collection or aggregate&rsquo;s implementation.</p>

<pre><code class="python SequenceProtocolIterators">
class AtoZ:

    def __getitem__(self, index):
        if 0 &lt;= index &lt; 26:
            return chr(index + ord("A"))
        raise IndexError()

if __name__ == '__main__':

    for letter in AtoZ():
        print(letter, end='')
</code></pre>

<pre><code class="python Two-Argument iter() Function Iterators">
class Presidents:

    __names = ("George Washington", "John Adams", "Thomas Jefferson", ...)

    def __init__(self, first=None):
        self.index = (-1 if first is None else Presidents.__names.index(first)-1)

    def __call__(self):
        self.index += 1
        if self.index &lt; len(Presidents.__names):
            return Presidents.__names(self.index)
        raise StopIteration()

if __name__ == '__main__':

    for president in iter(Presidents("George Bush"), None):
        print(president, end=" * ")
    print()
</code></pre>

<pre><code class="python IteratorProtocolIterators">class Bag:

    def __init__(self, items=None):
        self.__bag = {}
        if items is not None:
            for item in items:
                self.add(item)

    def add(self, item):
        self.__bag[item] = self.__bag.get(item, 0) + 1

    def __delitem__(self, item):
        if self.__bag.get(item) is not None:
            self.__bag[item] -= 1
            if self.__bag[item] &lt;= 0:
                del self.__bag[item]

        else:
            raise KeyError(str(item))

    def count(self, item):
        return self.__bag.get(item, 0)

    def __len__(self):
        return sum(count for count in self.__bag.values())

    def __contains__(self, item):
        return item in self.__bag

    def __iter__(self):
        items = []
        for item, count in self.__bag.items():
            for _ in range(count):
                items.append(item)
        return iter(items)
</code></pre>

<h3>3.5. Mediator</h3>

<p>The mediator pattern provides a means of creating an object - the mediator - that can
encapsulate the interactions between other objects. This makes it possible to achieve
iteractions between objects that have no direct knowledge of each other.</p>

<pre><code class="python Mediator">"""
Text   #1
Text   #2
             --&gt; Mediator --&gt; updateui()/clicked()
Button #1
Button #2
"""

class Form:

    def __init__(self):
        self.create_widgets()
        self.create_mediator()

    def create_widgets(self):
        self.nameText = Text()
        self.emailText = Text()
        self.okButton = Button("OK")
        self.cancelButton = Button("Cancel")

    def create_mediator(self):
        self.mediator = Mediator(((self.nameText, self.update_ui),
                                  (self.emailText, self.update_ui),
                                  (self.okButton, self.clicked),
                                  (self.cancelButton, self.clicked)))
        self.update_ui()

    def update_ui(self, widget=None):
        self.okButton.enabled = (bool(self.nameText.text) and bool(self.emailText.text))

    def clicked(self, widget):
        if widget == self.okButton:
            print("OK")
        elif widget == self.cancelButton:
            print("Cancel")

class Mediator:

    def __init__(self, widgetCallablePairs):
        self.callablesForWidget = collections.defaultdict(list)
        for widget, caller in widgetCallablePairs:
            self.callablesForWidget[widget].append(caller)
            widget.mediator = self

    def on_change(self, widget):
        callables = self.callablesForWidget.get(widget)
        if callables is not None:
            for caller in callables:
                caller(widget)
        else:
            raise AttributeError("No on_change() method registered for {}".format(widget))

class Mediated:

    def __init__(self):
        self.mediator = None

    def on_change(self):
        if self.mediator is not None:
            self.mediator.on_change(self)

class Button(Mediated):

    def __init__(self, text=""):
        super().__init__()
        self.enabled = True
        self.text = text

    def click(self):
        if self.enabled:
            self.on_change()

class Text(Mediated):

    def __init__(self, text=""):
        super().__init__()
        self.__text = text

    @property
    def text(self):
        return self.__text

    @text.setter
    def text(self, text):
        if self.text != text:
            self.__text = text
            self.on_change()
</code></pre>

<pre><code class="python Coroutine-Based Mediator">
def create_mediator(self):
    self.mediator = self._update_ui_mediator(self._clicked_mediator())
    for widget in (self.nameText, self.emailText, self.okButton, self.cancelButton):
        widget.mediator = self.mediator
    self.mediator.send(None)

@coroutine
def _update_ui_mediator(self, successor=None):
    while True:
        widget = (yield)
        self.okButton.enabled = (bool(self.nameText.text) and bool(self.emailText.text))

        if successor is not None:
            successor.send(widget)

@coroutine
def _clicked_mediator(self, successor=None):
    while True:
        widget = (yield)
        if widget == self.okButton:
            print("OK")
        elif widget == self.cancelButton:
            print("Cancel")
        elif successor is not None:
            successor.send(widget)

class Mediated:

    def __init__(self):
        self.mediator = None

    def on_change(self):
        if self.mediator is not None:
            self.mediator.send(self)
</code></pre>

<h3>3.6. Memento</h3>

<p>The memento pattern is a means of saving and restoring an object&rsquo;s state without
violating encapsulation.</p>

<h3>3.7. Observer</h3>

<p>The observer pattern supports many-to-many dependency relationships between objects,
such that when one object changes state, all its related objects are notified.</p>

<p>Nowadays, probably the most commmon expression of this pattern and its variants is
the mode/view/controller(MVC) paradigm. In this paradigm, a model represents data,
one or more views visualize that data, and one or more controllers mediate between
input(e.g. user interaction) and the model. And any changes to the model are
automatically reflected in the associated views.</p>

<pre><code class="python Observer">"""
SliderModel
  |----&gt; HistoryView
  |----&gt; LiveView
"""

class Observed:

    def __init__(self):
        self.__observers = set()

    def observers_add(self, observer, *observers):
        for observer in itertools.chain((observer,), observers):
            self.__observers.add(observer)
            observer.update(self)

    def observer_discard(self, observer):
        self.__observers.discard(observer)

    def observers_notify(self):
        for observer in self.__observers:
            observer.update(self)

class SliderModel(Observed):

    def __init__(self, minimum, value, maximum):
        super().__init_()
        self.__minimum = self.__value = self.__mximum = None
        self.minimum = minimum
        self.value = value
        self.maximum = maximum

    @property
    def value(self):
        return self.__value

    @value.setter
    def value(self, value):
        if self.__value != value:
            self.__value = value
            self.observers_notify()

class HistoryView:

    def __init__(self):
        self.data = []

    def update(self, model):
        self.data.append((model.value, time.time()))

class LiveView:

    def __init__(self, length=40):
        self.length = length

    def update(self, model):
        tippingPoint = round(model.value * self.length / (model.maximum - model.minimum))
        td = ""
        html = ""
        html.extend("")
        print("".join(html))


if __name__ == '__main__':

    historyView = HistoryView()
    liveView = LiveView()
    model = SliderModel(0, 0, 40)
    model.observers_add(historyView, liveView)
    for value in (7, 23, 37):
        model.value = value
    for value, timestamp in historyView.data:
        print("{:3} {}".format(value, datetime.datetime.fromtimestamp(timestamp)), file=sys.stderr)
</code></pre>

<h3>3.8. State</h3>

<p>The state pattern is intended to provide objects whose behavior changes when their state
changes; that is, objects that have modes.</p>

<pre><code class="python State">class Counter:

    def __init__(self, *names):
        pass

    def __call__(self, event):
        pass

class Event:

    def __init__(self, name, count=1):
        pass

class Multiplexer:

    ACTIVE, DORMANT = ("ACTIVE", "DORMANT")

    def __init__(self):
        pass

    def connect(self, eventName, callback):
        pass

    def disconnect(self, eventName, callback=None):
        pass

    def send(self, event):
        pass

    # @property
    # def state(self):
    #     pass

    @state.setter
    def state(self, state):
        pass

    def __active_connect(self, eventName, callback):
        pass


if __name__ == '__main__':

    totalCounter = Counter()
    carCounter = Counter("cars")
    commercialCounter = Counter("vans", "trucks")

    multiiplexer = Multiplexer()
    for eventName, callback in (("cars", carCounter), 
                                ("vans", commercialCounter),
                                ("trucks", commercialCounter)):
        multiplexer.connect(eventName, callback)
        multiplexer.connect(eventName, totalCounter)
</code></pre>

<h3>3.9. Strategy</h3>

<p>The strategy pattern provides a means of encapsulating a set of algorithms that
can be used interchangeably, depending on the user&rsquo;s needs.</p>

<pre><code class="python Strategy">WINNERS = ("Niko", "Mat", "Birgit", "Sawao")

class Layout:

    def __init__(self, tabulator):
        self.tabulator = tabulator

    def tabulate(self, rows, items):
        return self.tabulator(rows, items)


class Layout:

    def __init__(self, tabulator):
        self.tabulate = tabulator

    def html_tabulator(rows, items):
        pass

if __name__ == '__main__':

    htmlLayout = Layout(html_tabulator)
    for rows in range(2, 6):
        print(htmlLayout.tabulate(rows, WINNERS))

    textLayout = Layout(text_tabulator)
    for rows in range(2, 6):
        print(textLayout.tabulate(rows, WINNERS)
</code></pre>

<h3>3.10. Template method</h3>

<p>The template method pattern allows us to define the steps of an algorithm but defer the
execution of some of those steps to subclasses.</p>

<pre><code class="python TemplateMethod">def count_words(filename):
    pass

class AbstractWordCounter:

    @staticmethod
    def can_count(filename):
        raise NotImplementedError()

    @staticmethod
    def count(filename):
        raise NotImplementedError()

class AbstractWordCounter(metaclass=abc.ABCMeta):

    @staticmethod
    @abc.abcstractmethod
    def can_count(filename):
        pass

    @staticmethod
    @abc.abcstractmethod
    def count(filename):
        pass

class PlainTextWordCounter(AbstractWordCounter):

    @staticmethod
    def can_count(filename):
        pass

    @staticmethod
    def count(filename):
        pass

class HtmlWordCounter(AbstactWordCounter):

    @staticmethod
    def can_count(filename):
        pass

    @staticmethod
    def count(filename):
        pass

    class __HtmlParser(html.parser.HTMLParser):

        def __init__(self):
            super().__init__()
            pass

        def handle_starttag(self, tag, attrs):
            pass

        def handle_endtag(self, tag):
            pass

        def handle_data(self, text):
            pass
</code></pre>

<h3>3.11. Visitor</h3>

<p>The visitor pattern is used to apply a function to every item in a collection or
aggregate object.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started With Spring MVC]]></title>
    <link href="http://k.arttechresearch.com/tech/2016/02/14/getting-started-with-spring-mvc/"/>
    <updated>2016-02-14T18:04:37+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2016/02/14/getting-started-with-spring-mvc</id>
    <content type="html"><![CDATA[<p>Steps</p>

<ul>
<li>Installations</li>
<li>Project creation</li>
</ul>


<h2>Installations</h2>

<ul>
<li>Java 8</li>
<li>Maven 3: a build tool</li>
<li>Tomcat 8: a web server</li>
<li>Eclipse: IDE</li>
</ul>


<h3>Java</h3>

<pre><code class="bash">$ sudo add-apt-repository -y ppa:webupd8team/java
$ sudo apt-get update
$ sudo apt-get install -y oracle-java8-installer
$ java -version
</code></pre>

<h3>Maven</h3>

<p><a href="http://maven.apache.org/download.cgi">maven</a></p>

<pre><code class="bash">$ wget http://apache.mirror.anlx.net/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.zip
$ sudo unzip apache-maven-3.3.9-bin.zip
$ sudo mv apache-maven-3.3.9/ /usr/local/maven/
$ vim ~/.bashrc
$ source ~/.bashrc
$ mvn -v
</code></pre>

<p><code>~/.bashrc</code></p>

<pre><code class="bash"># maven
export MAVEN_HOME=/usr/local/maven
export PATH=$PATH:$MAVEN_HOME/bin
</code></pre>

<h3>Tomcat</h3>

<p><a href="http://tomcat.apache.org/download-80.cgi">Tomcat</a></p>

<pre><code class="bash">$ wget http://www.mirrorservice.org/sites/ftp.apache.org/tomcat/tomcat-8/v8.0.32/bin/apache-tomcat-8.0.32.zip
$ sudo unzip apache-tomcat-8.0.32.zip
$ sudo mv apache-tomcat-8.0.32/ /usr/local/tomcat/
$ cd /usr/local/tomcat/
$ sudo chmod +x bin/*.sh
$ sudo bin/catalina.sh run
$ cd /tmp
$ curl http://localhost:8080
</code></pre>

<h3>Eclipse</h3>

<p><a href="http://www.eclipse.org/downloads/">Eclipse IDE for Java EE Developers</a></p>

<h2>Project Creation</h2>

<ul>
<li>creating a maven project</li>
</ul>


<h3>Maven Project</h3>

<p><a href="https://maven.apache.org/guides/getting-started/">Maven Getting Started</a></p>

<h4>mvn</h4>

<pre><code class="bash">$ mvn -B archetype:generate \
      -DarchetypeGroupId=org.apache.maven.archetypes \
      -DgroupId=com.mycompany.app \
      -DartifactId=my-app \
      -DarchetypeArtifactId=maven-archetype-quickstart \
      -DinteractiveMode=false \
      -Dpackaging=war
</code></pre>

<p>folder</p>

<pre><code>my-app
|-- pom.xml
`-- src
    |-- main
    |   `-- java
    |       `-- com
    |           `-- mycompany
    |               `-- app
    |                   `-- App.java
    `-- test
        `-- java
            `-- com
                `-- mycompany
                    `-- app
                        `-- AppTest.java
</code></pre>

<h4>pom.xml</h4>

<p>Dependencies:</p>

<ul>
<li>Servlet</li>
<li>Spring</li>
</ul>


<p>edit pom.xml</p>

<p>```xml
<properties>
    &lt;java.version>1.8&lt;/java.version>
    &lt;spring.version>4.1.6.RELEASE&lt;/spring.version>
</properties></p>

<p><dependencies></p>

<pre><code>&lt;!-- Servlet API --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;

&lt;!-- Spring Core --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Spring MVC --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p></dependencies></p>

<!-- boilerplate code allowing Maven to generate a .war archive without requiring a web.xml file -->


<p><build>
    <finalName>springwebapp</finalName></p>

<pre><code>&lt;plugins&gt;
    &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.6&lt;/version&gt;
        &lt;configuration&gt;
            &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;
        &lt;/configuration&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>

<p></build>
```</p>

<h3>Spring MVC</h3>

<pre><code class="bash">$ cd src/main/java/com/&lt;groupId&gt;/
$ mkdir config
$ mkdir controller
</code></pre>

<h4>Config</h4>

<pre><code class="java AppConfig.java">package com.todo.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;

@Configuration
@EnableWebMvc
@ComponentScan(basePackages = {"com.todo.controller"})
public class AppConfig{
}
</code></pre>

<pre><code class="java ServletInitializer.java">package com.todo.config;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

public class ServletInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

  @Override
  protected Class&lt;?&gt;[] getRootConfigClasses() {
    return new Class&lt;?&gt;[0];
  }

  @Override
  protected Class&lt;?&gt;[] getServletConfigClasses() {
    return new Class&lt;?&gt;[]{AppConfig.class};
  }

  @Override
  protected String[] getServletMappings() {
    return new String[]{"/"};
  }
}
</code></pre>

<h4>Controller</h4>

<pre><code class="java HelloController.java">package com.todo.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class HelloController {
  @RequestMapping("hi")
  @ResponseBody
  public String hi() {
    return "Hello world.";
  }
}
</code></pre>

<h3>Run</h3>

<pre><code class="bash">$ mvn clean install
$ sudo cp target/springwebapp.war /usr/local/tomcat/webapps/
$ curl http://localhost:8080/springwebapp/hi
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Installing Caffe on Ubuntu 14.04]]></title>
    <link href="http://k.arttechresearch.com/tech/2016/02/03/installing-caffe-on-ubuntu-14-dot-04/"/>
    <updated>2016-02-03T05:07:12+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2016/02/03/installing-caffe-on-ubuntu-14-dot-04</id>
    <content type="html"><![CDATA[<h2>Prequisitions</h2>

<ul>
<li>Vagrant/VirtualBox</li>
<li>Ubuntu 14.04</li>
<li>VM Memory: 4096 MB</li>
</ul>


<h2>Caffe Installation</h2>

<p>Requirements</p>

<ul>
<li>CUDA</li>
<li>BLAS</li>
<li>OpenCV</li>
<li>Anaconda</li>
<li>Boost</li>
<li>Caffe dependencies</li>
<li>Protobuf</li>
<li>Caffe</li>
</ul>


<h3>CUDA</h3>

<pre><code class="bash"># reference: https://gist.github.com/titipata/f0ef48ad2f0ebc07bcb9
# check version
$ lspci | grep -i nvidia
$ uname -m &amp;&amp; cat /etc/*release
$ gcc --version

# CUDA
$ cd /tmp
$ wget http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1404/x86_64/cuda-repo-ubuntu1404_6.5-14_amd64.deb
$ sudo dpkg -i cuda-repo-ubuntu1404_6.5-14_amd64.deb
$ sudo apt-get update
$ sudo apt-get install cuda
$ sudo reboot
</code></pre>

<h3>BLAS</h3>

<pre><code class="bash">$ sudo apt-get install libopenblas-dev
</code></pre>

<h3>OpenCV</h3>

<pre><code class="bash">$ sudo apt-get install git unzip
$ cd /tmp
$ wget https://raw.githubusercontent.com/jayrambhia/Install-OpenCV/master/Ubuntu/2.4/opencv2_4_9.sh
$ sudo chmod +x opencv2_4_9.sh
$ ./opencv2_4_9.sh
</code></pre>

<h3>Anaconda</h3>

<pre><code class="bash">$ cd /tmp
$ wget http://09c8d0b2229f813c1b93-c95ac804525aac4b6dba79b00b39d1d3.r79.cf1.rackcdn.com/Anaconda-2.1.0-Linux-x86_64.sh
$ sudo bash Anaconda-2.1.0-Linux-x86.sh
# path: /usr/local/anaconda
</code></pre>

<h3>Boost</h3>

<pre><code class="bash">$ sudo apt-get install libboost-all-dev
</code></pre>

<h3>Caffe dependencies</h3>

<pre><code class="bash"># reference: http://caffe.berkeleyvision.org/install_apt.html
$ sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libboost-all-devlibhdf5-serial-dev
$ sudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-dev protobuf-compiler
</code></pre>

<h3>Protobuf</h3>

<pre><code class="bash">$ sudo apt-get install python-pip
$ sudo pip install protobuf
</code></pre>

<h3>Caffe</h3>

<pre><code class="bash">$ cd /usr/local
$ sudo git clone https://github.com/BVLC/caffe
$ cd caffe/
$ sudo cp Makefile.config.example Makefile.config
# modify Makefile.config if needed
###################################################
# CPU-only switch (uncomment to build without GPU support).
CPU_ONLY := 1
###################################################

$ sudo make all
$ sudo make test
$ sudo vim ~/.bashrc              # update paths
$ source ~/.bashrc
$ make runtest
...
[----------] Global test environment tear-down
[==========] 1019 tests from 144 test cases ran. (34669 ms total)
[  PASSED  ] 1019 tests.
</code></pre>

<p><code>~/.bashrc</code> config:</p>

<pre><code class="bash"># CUDA
export PATH=/usr/local/cuda-7.5/bin:$PATH
export LD_LIBRARY_PATH=/usr/local/cuda-7.5/lib64:$LD_LIBRARY_PATH
export PATH
# Anaconda
export PATH=/usr/local/anaconda/bin:$PATH
# Caffe Root
export CAFFE_ROOT=/usr/local/caffe
</code></pre>

<p>config python library</p>

<pre><code class="bash">$ sudo make pycaffe
$ sudo make distribute
# make dir for custom python modules, install caffe
$ mkdir ~/pycaffe
$ mv distribute/python/caffe ~/pycaffe
#################################################################
# set PYTHONPATH (this should go in your .bashrc or whatever
# export PYTHONPATH=${HOME}/pycaffe:$PYTHONPATH
export PYTHONPATH=/usr/local/caffe/python:$PYTHONPATH
#################################################################
</code></pre>

<p>Install the python dependencies</p>

<pre><code class="bash">$ cd /usr/local/cafffe/python
$ sudo pip install -r requirements.txt
</code></pre>

<p>import caffe on IPython</p>

<pre><code class="bash"># fixed Anaconda issue
$ sudo rm /usr/local/anaconda/lib/libm.*
$ ipython
$ conda install protobuf
# import caffe
$ cd /usr/local/caffe/python
$ import caffe
</code></pre>

<p>import caffe on python script</p>

<pre><code># import matplotlib for fixing the issue when importing caffe
# so, matplotlib is a must
import matplotlib
matplotlib.use('Agg')

import sys
sys.path.insert(0, '/usr/local/caffe/python/')
import caffe
</code></pre>

<h2>DeepDream</h2>

<h3>IPython Notebook (Optional)</h3>

<pre><code class="bash">$ sudo pip install ipython
$ sudo pip install jupyter
$ ipython notebook --ip 0.0.0.0
</code></pre>

<p>ipython notebook url: <a href="http://localhost:8888">http://localhost:8888</a></p>

<h3>Dependencies</h3>

<ul>
<li>Python: scipy, numpy, pillow</li>
</ul>


<pre><code class="bash"># python
$ sudo apt-get install python-dev python-virtualenv
# pillow
$ sudo apt-get install libtiff5-dev libjpeg8-dev zlib1g-dev \
libfreetype6-dev liblcms2-dev libwebp-dev tcl8.6-dev tk8.6-dev python-tk
# scipy
$ sudo apt-get install libblas-dev liblapack-dev libatlas-base-dev gfortran
</code></pre>

<p><code>base.txt</code>: python requirements</p>

<pre><code># NOTE: if it doesn't run on anaconda, `scikit-image` and `cython` 
# must be installed on PYTHONPATH. Otherwise, it will show some 
# errors when `import caffe`.
numpy==1.10.4
Pillow==3.1.0
scipy==0.17.0
protobuf==2.6.1
scikit-image==0.11.3
cython==0.23.4
</code></pre>

<pre><code class="bash">$ sudo pip install -r base.txt
</code></pre>

<h3>Repo</h3>

<pre><code class="bash">$ git clone https://github.com/google/deepdream.git
$ cd deepdream
</code></pre>

<h3>Models</h3>

<pre><code class="bash">$ wget wget -P /usr/local/caffe/models/bvlc_googlenet http://dl.caffe.berkeleyvision.org/bvlc_googlenet.caffemodel
</code></pre>

<h3>Run</h3>

<pre><code class="bash">$ ipython notebook ./dream.ipynb
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Solving a Technical Question]]></title>
    <link href="http://k.arttechresearch.com/tech/2016/01/14/solving-a-technical-question/"/>
    <updated>2016-01-14T15:24:40+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2016/01/14/solving-a-technical-question</id>
    <content type="html"><![CDATA[<p>Source: Cracking the Coding Interview</p>

<p>5 Steps</p>

<ol>
<li>Ask questions.</li>
<li>Design a algorithm.</li>
<li>Pseudocode</li>
<li>Code</li>
<li>Test</li>
</ol>


<h2>1. Ask Questions</h2>

<ul>
<li>What are the data types?</li>
<li>How much data is there?</li>
<li>What assuptions do you need to solve the problem?</li>
<li>WHo is the user?</li>
</ul>


<h2>2. Design a algorithm</h2>

<ul>
<li>What are its space and time complexity?</li>
<li>What happens if there is a lot of data?</li>
<li>Does your design cause other issues? For example, if you&rsquo;re creating a modified version of a binary search tree, did your design impact the time for insert, find, or delete?</li>
<li>If there are other issues or limitations, did you make the right trade-offs? For which scenarios might the trade-off be less optimal?</li>
<li>If they gave you specific data (e.g., mentioned that the data is ages, or in sorted order), have you leveraged that information? Usually there&rsquo;s a reason that an inter- viewer gave you specific information.</li>
</ul>


<p>approaches</p>

<ul>
<li>examplify</li>
<li>pattern matching</li>
<li>simplify and generalize</li>
<li>base case and build</li>
<li>data structure brainstorm</li>
</ul>


<h2>3. Pseudocode</h2>

<h2>4. Code</h2>

<ul>
<li>correct: expected and unexpected inputs</li>
<li>efficient: time and space</li>
<li>simple</li>
<li>readable</li>
<li>maintainable</li>
</ul>


<h2>5. Test</h2>

<ul>
<li>Extremecases: 0, negative, null, maximums, minimums.</li>
<li>User error:What happens if the user passes in null or a negative value?</li>
<li>General cases: Test the normal case.</li>
</ul>

]]></content>
  </entry>
  
</feed>
