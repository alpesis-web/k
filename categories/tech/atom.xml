<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | Kelly Chan]]></title>
  <link href="http://k.arttechresearch.com/categories/tech/atom.xml" rel="self"/>
  <link href="http://k.arttechresearch.com/"/>
  <updated>2015-10-16T23:23:52+08:00</updated>
  <id>http://k.arttechresearch.com/</id>
  <author>
    <name><![CDATA[Kelly Chan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Adding TOC Plugin for Octopress]]></title>
    <link href="http://k.arttechresearch.com/tech/2015/10/16/adding-toc-plugin-for-octopress/"/>
    <updated>2015-10-16T22:31:58+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2015/10/16/adding-toc-plugin-for-octopress</id>
    <content type="html"><![CDATA[<h2>1. Plugin: toc_generator.rb</h2>

<h3>1.1. toc_generator.rb</h3>

<p>octopress/plugins/toc_generator.rb</p>

<pre><code class="ruby toc_generator.rb">require 'nokogiri'

module Jekyll

  module TOCGenerator

    TOGGLE_HTML = '&lt;div id="toctitle"&gt;&lt;h2&gt;%1&lt;/h2&gt;%2&lt;/div&gt;'
    TOC_CONTAINER_HTML = '&lt;div id="toc-container"&gt;&lt;table class="toc" id="toc"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;%1&lt;ul&gt;%2&lt;/ul&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;'
    HIDE_HTML = '&lt;span class="toctoggle"&gt;[&lt;a id="toctogglelink" class="internal" href="#"&gt;%1&lt;/a&gt;]&lt;/span&gt;'

    def toc_generate(html)
      # No Toc can be specified on every single page
      # For example the index page has no table of contents
      no_toc = @context.environments.first["page"]["noToc"] || false;

      return html if no_toc

      config = @context.registers[:site].config

      # Minimum number of items needed to show TOC, default 0 (0 means no minimum)
      min_items_to_show_toc = config["minItemsToShowToc"] || 0

      anchor_prefix = config["anchorPrefix"] || 'tocAnchor-'

      # better for traditional page seo, commonlly use h1 as title
      toc_top_tag = config["tocTopTag"] || 'h1'
      toc_top_tag = toc_top_tag.gsub(/h/, '').to_i

      toc_top_tag = 5 if toc_top_tag &gt; 5

      toc_sec_tag = toc_top_tag + 1
      toc_top_tag = "h#{toc_top_tag}"
      toc_sec_tag = "h#{toc_sec_tag}"


      # Text labels
      contents_label     = config["contentsLabel"] || 'Contents'
      hide_label         = config["hideLabel"] || 'hide'
      # show_label       = config["showLabel"] || 'show' # unused
      show_toggle_button = config["showToggleButton"]

      toc_html = ''
      toc_level = 1
      toc_section = 1
      item_number = 1
      level_html = ''

      doc = Nokogiri::HTML(html)

      # Find H1 tag and all its H2 siblings until next H1
      doc.css(toc_top_tag).each do |tag|
        # TODO This XPATH expression can greatly improved
        ct    = tag.xpath("count(following-sibling::#{toc_top_tag})")
        sects = tag.xpath("following-sibling::#{toc_sec_tag}[count(following-sibling::#{toc_top_tag})=#{ct}]")

        level_html    = '';
        inner_section = 0;

        sects.map.each do |sect|
          inner_section += 1;
          anchor_id = [
                        anchor_prefix, toc_level, '-', toc_section, '-',
                        inner_section
                      ].map(&amp;:to_s).join ''

          sect['id'] = "#{anchor_id}"

          level_html += create_level_html(anchor_id,
                                          toc_level + 1,
                                          toc_section + inner_section,
                                          item_number.to_s + '.' + inner_section.to_s,
                                          sect.text,
                                          '')
        end

        level_html = '&lt;ul&gt;' + level_html + '&lt;/ul&gt;' if level_html.length &gt; 0

        anchor_id = anchor_prefix + toc_level.to_s + '-' + toc_section.to_s;
        tag['id'] = "#{anchor_id}"

        toc_html += create_level_html(anchor_id,
                                      toc_level,
                                      toc_section,
                                      item_number,
                                      tag.text,
                                      level_html);

        toc_section += 1 + inner_section;
        item_number += 1;
      end

      # for convenience item_number starts from 1
      # so we decrement it to obtain the index count
      toc_index_count = item_number - 1

      return html unless toc_html.length &gt; 0

      hide_html = '';
      hide_html = HIDE_HTML.gsub('%1', hide_label) if (show_toggle_button)

      if min_items_to_show_toc &lt;= toc_index_count
        replaced_toggle_html = TOGGLE_HTML
        .gsub('%1', contents_label)
        .gsub('%2', hide_html);

        toc_table = TOC_CONTAINER_HTML
        .gsub('%1', replaced_toggle_html)
        .gsub('%2', toc_html);

        doc.css('body').children.before(toc_table)
      end

      doc.css('body').children.to_xhtml(indent:3, indent_text:" ")
    end

    private

    def create_level_html(anchor_id, toc_level, toc_section, tocNumber, tocText, tocInner)
      link = '&lt;a href="#%1"&gt;&lt;span class="tocnumber"&gt;%2&lt;/span&gt; &lt;span class="toctext"&gt;%3&lt;/span&gt;&lt;/a&gt;%4'
      .gsub('%1', anchor_id.to_s)
      .gsub('%2', tocNumber.to_s)
      .gsub('%3', tocText)
      .gsub('%4', tocInner ? tocInner : '');
      '&lt;li class="toc_level-%1 toc_section-%2"&gt;%3&lt;/li&gt;'
      .gsub('%1', toc_level.to_s)
      .gsub('%2', toc_section.to_s)
      .gsub('%3', link)
    end

  end

end

Liquid::Template.register_filter(Jekyll::TOCGenerator)
</code></pre>

<h3>1.2. Gemfile</h3>

<pre><code>gem 'nokogiri'
</code></pre>

<h3>1.3. _config.yml</h3>

<pre><code class="yml _config.yml">#---------------------------#
#      TOC Settings         #
#---------------------------#

minItemsToShowToc: 0
tocTopTag: h1
anchorPrefix: tocAnchor-
showToggleButton: false
</code></pre>

<p>Variable definitions</p>

<table>
<tr>
<th>Parameter name</th>
<th>Description</th>
<th>Default value</th>
</tr>

<tr>
<td>minItemsToShowToc</td>
<td>Minimum number of items to show the TOC<br/>Suppose you want to generated the TOC only if there are at least 3 H1</td>
<td>0 (no limit)</td>
</tr>

<tr>
<td>tocTopTag</td>
<td>The top level tag given nokogiri to find<br/>Suppose you want to generated the TOC start form h1 to h5</td>
<td>h1</td>
</tr>
<tr>
<td>anchorPrefix</td>
<td>The prefix used to generate the anchor name</td>
<td>tocAnchor-</td>
</tr>

<tr>
<td>showToggleButton</td>
<td>The TOC has a button used to collapse/expand the list, this requires a little of Javascript
<br/>This package contains a jQuery plugin to handle the click</td>
<td>false</td>
</tr>
</table>


<h2>2. HTML: source/_includes/article.html</h2>

<p>source/_includes/article.html</p>

<pre><code class="html article.html">    &lt;div&gt;
        {\{ content | toc_generate }\}
    &lt;/div&gt;
</code></pre>

<h2>3. SASS: _toc_generator.scss</h2>

<p>sass/plugins/_toc_generator.scss</p>

<pre><code class="css _toc_generator.scss">#toc, .toc, .mw-warning {
    background-color: #F9F9F9;
    border: 1px solid #AAAAAA;
    font-size: 95%;
    padding: 5px;
}
#toc h2, .toc h2 {
    border: medium none;
    display: inline;
    font-size: 100%;
    font-weight: bold;
    padding: 0;
}
#toc #toctitle, .toc #toctitle, #toc .toctitle, .toc .toctitle {
    text-align: center;
    margin:0 8px 4px 14px;
    padding-top:8px;
    line-height: 1.5;
    overflow:hidden;
}


#toc ul, .toc ul {
    list-style-image: none;
    list-style-type: none;
    margin:0 8px 7px 14px;
    padding-left: 0;
    text-align: left;
}
#toc ul ul, .toc ul ul {
    margin: 0 0 0 2em;
}
#toc .toctoggle, .toc .toctoggle {
    font-size: 94%;
}

#toc ul li {
    list-style-type: none;
    padding-left: 0;
}

#toc-container {
    margin-bottom: 10px;
}
</code></pre>

<h2>4. Javascript: jquery.tocLight.js</h2>

<pre><code class="javascript jquery.tocLight.js">/*
 * jQuery Table of Content Generator Support for Jekyll v1.0
 *
 * https://github.com/dafi/jekyll-tocmd-generator
 * Examples and documentation at: https://github.com/dafi/jekyll-tocmd-generator
 *
 * Requires: jQuery v1.7+
 *
 * Copyright (c) 2013 Davide Ficano
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */
(function($) {
    $.toc = {};
    $.toc.clickHideButton = function(settings) {
        var config = {
            saveShowStatus: false,
            hideText: 'hide',
            showText: 'show'};

        if (settings) {
            $.extend(config, settings);
        }

        $('#toctogglelink').click(function() {
            var ul = $($('#toc ul')[0]);

            if (ul.is(':visible')) {
                ul.hide();
                $(this).text(config.showText);
                if (config.saveShowStatus) {
                    $.cookie('toc-hide', '1', { expires: 365, path: '/' });
                }
                $('#toc').addClass('tochidden');
            } else {
                ul.show();
                $(this).text(config.hideText);
                if (config.saveShowStatus) {
                    $.removeCookie('toc-hide', { path: '/' });
                }
                $('#toc').removeClass('tochidden');
            }
            return false;
        });

        if (config.saveShowStatus &amp;&amp; $.cookie('toc-hide')) {
            var ul = $($('#toc ul')[0]);

            ul.hide();
            $('#toctogglelink').text(config.showText);
            $('#toc').addClass('tochidden');
        }

    }
})(jQuery);
</code></pre>

<p>update the html template</p>

<pre><code class="html article.html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{\{ page.title }\}&lt;/title&gt;

    &lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="js/jquery.tocLight.js"&gt;&lt;/script&gt;

    &lt;script type="text/javascript"&gt;
        $(function() {
          $.toc.clickHideButton();
        });
  &lt;/script&gt;

  &lt;/head&gt;
  &lt;body id="small"&gt;
        {\{ content | toc_generate }\}
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2>4. Testing</h2>

<p><code>rake generate</code> and <code>rake preview</code></p>

<h2>Reference</h2>

<ul>
<li><a href="https://github.com/dafi/jekyll-toc-generator">jekyll-toc-generator</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using MathJax With Octopress]]></title>
    <link href="http://k.arttechresearch.com/tech/2015/10/13/using-mathjax-with-octopress/"/>
    <updated>2015-10-13T10:26:29+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2015/10/13/using-mathjax-with-octopress</id>
    <content type="html"><![CDATA[<h2>1. Adding MathJax</h2>

<pre><code class="bash">$ vim octopress/_includes/mathjax.html
</code></pre>

<p>mathjax.html</p>

<p>```html</p>

<!-- MathJax -->


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>


<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<pre><code>
## 2. Including MathJax in head.html
</code></pre>

<p>$ vim octopress/_includes/head.html
```</p>

<p>head.html</p>

<pre><code class="html">{\% include mathjax.html %\}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Adding Tag Generator in Octopress]]></title>
    <link href="http://k.arttechresearch.com/tech/2015/10/06/adding-tag-generator-in-octopress/"/>
    <updated>2015-10-06T05:42:01+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2015/10/06/adding-tag-generator-in-octopress</id>
    <content type="html"><![CDATA[<p>Feature: add the links for the tags.</p>

<p>Steps:</p>

<ol>
<li>update the ruby plugin: <code>octopress/plugins/tag_generator.rb</code></li>
<li>update the html in source: <code>octopress/source/_layouts/tag_index.html</code></li>
<li>update the <code>tag_dir</code> in _config.yml: <code>octopress/_config.yml</code></li>
</ol>


<h2>1. Plugin: tag_generator.rb</h2>

<pre><code class="ruby tag_generator.rb"># encoding: utf-8
#
# Jekyll tag page generator.
#
# Based on Jekyll tag category generator:
#
#     http://recursive-design.com/projects/jekyll-plugins/
#
#     Version: 0.1.4 (201101061053)
#
#     Copyright (c) 2010 Dave Perrett, http://recursive-design.com/
#     Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
#
# A generator that creates tag pages for jekyll sites.
#
# Included filters :
# - tag_links:      Outputs the list of tags as comma-separated &lt;a&gt; links.
# - date_to_html_string: Outputs the post.date as formatted html, with hooks for CSS styling.
#
# Available _config.yml settings :
# - tag_dir:          The subfolder to build tag pages in (default is 'tags').
# - tag_title_prefix: The string used before the tag name in the page title (default is
#                          'Tag: ').

require 'stringex'

module Jekyll

  # The TagIndex class creates a single tag page for the specified tag.
  class TagIndex &lt; Page

    # Initializes a new TagIndex.
    #
    #  +base+         is the String path to the &lt;source&gt;.
    #  +tag_dir+ is the String path between &lt;source&gt; and the tag folder.
    #  +tag+     is the tag currently being processed.
    def initialize(site, base, tag_dir, tag)
      @site = site
      @base = base
      @dir  = tag_dir
      @name = 'index.html'
      self.process(@name)
      # Read the YAML data from the layout page.
      self.read_yaml(File.join(base, '_layouts'), 'tag_index.html')
      self.data['tag']    = tag
      # Set the title for this page.
      title_prefix             = site.config['tag_title_prefix'] || 'Tag: '
      self.data['title']       = "#{title_prefix}#{tag}"
      # Set the meta-description for this page.
      meta_description_prefix  = site.config['tag_meta_description_prefix'] || 'Tag: '
      self.data['description'] = "#{meta_description_prefix}#{tag}"
    end

  end

  # The TagFeed class creates an Atom feed for the specified tag.
  class TagFeed &lt; Page

    # Initializes a new TagFeed.
    #
    #  +base+         is the String path to the &lt;source&gt;.
    #  +tag_dir+ is the String path between &lt;source&gt; and the tag folder.
    #  +tag+     is the tag currently being processed.
    def initialize(site, base, tag_dir, tag)
      @site = site
      @base = base
      @dir  = tag_dir
      @name = 'atom.xml'
      self.process(@name)
      # Read the YAML data from the layout page.
      self.read_yaml(File.join(base, '_includes/custom'), 'tag_feed.xml')
      self.data['tag']    = tag
      # Set the title for this page.
      title_prefix             = site.config['tag_title_prefix'] || 'Tag: '
      self.data['title']       = "#{title_prefix}#{tag}"
      # Set the meta-description for this page.
      meta_description_prefix  = site.config['tag_meta_description_prefix'] || 'Tag: '
      self.data['description'] = "#{meta_description_prefix}#{tag}"

      # Set the correct feed URL.
      self.data['feed_url'] = "#{tag_dir}/#{name}"
    end

  end

  # The Site class is a built-in Jekyll class with access to global site config information.
  class Site

    # Creates an instance of TagIndex for each tag page, renders it, and
    # writes the output to a file.
    #
    #  +tag_dir+ is the String path to the tag folder.
    #  +tag+     is the tag currently being processed.
    def write_tag_index(tag_dir, tag)
      index = TagIndex.new(self, self.source, tag_dir, tag)
      index.render(self.layouts, site_payload)
      index.write(self.dest)
      # Record the fact that this page has been added, otherwise Site::cleanup will remove it.
      self.pages &lt;&lt; index

      # Create an Atom-feed for each index.
      if self.config['tag_feeds']
        feed = TagFeed.new(self, self.source, tag_dir, tag)
        feed.render(self.layouts, site_payload)
        feed.write(self.dest)
        # Record the fact that this page has been added, otherwise Site::cleanup will remove it.
        self.pages &lt;&lt; feed
      end
    end

    # Loops through the list of tag pages and processes each one.
    def write_tag_indexes
      if self.layouts.key? 'tag_index'
        dir = self.config['tag_dir'] || 'tags'
        self.tags.keys.each do |tag|
          self.write_tag_index(File.join(dir, tag.to_url), tag)
        end

      # Throw an exception if the layout couldn't be found.
      else
        raise &lt;&lt;-ERR


===============================================
 Error for tag_generator.rb plugin
-----------------------------------------------
 No 'tag_index.hmtl' in source/_layouts/
 Perhaps you haven't installed a theme yet.
===============================================

ERR
      end
    end

  end


  # Jekyll hook - the generate method is called by jekyll, and generates all of the tag pages.
  class GenerateTags &lt; Generator
    safe true
    priority :low

    def generate(site)
      site.write_tag_indexes
    end

  end


  # Adds some extra filters used during the tag creation process.
  module Filters

    # Outputs a list of tags as comma-separated &lt;a&gt; links. This is used
    # to output the tag list for each post on a tag page.
    #
    #  +tags+ is the list of tags to format.
    #
    # Returns string
    #
    def tag_links(tags)
      tags = tags.sort!.map { |c| tag_link c }

      case tags.length
      when 0
        ""
      when 1
        tags[0].to_s
      else
        "#{tags[0...-1].join(', ')}, #{tags[-1]}"
      end
    end

    # Outputs a single tag as an &lt;a&gt; link.
    #
    #  +tag+ is a tag string to format as an &lt;a&gt; link
    #
    # Returns string
    #
    def tag_link(tag)
      dir = @context.registers[:site].config['tag_dir']
      "&lt;a class='tag' href='http://k.arttechresearch.com/#{dir}/#{tag.to_url}/'&gt;#{tag}&lt;/a&gt;"
    end

    # Outputs the post.date as formatted html, with hooks for CSS styling.
    #
    #  +date+ is the date object to format as HTML.
    #
    # Returns string
    def date_to_html_string(date)
      result = '&lt;span class="month"&gt;' + date.strftime('%b').upcase + '&lt;/span&gt; '
      result += date.strftime('&lt;span class="day"&gt;%d&lt;/span&gt; ')
      result += date.strftime('&lt;span class="year"&gt;%Y&lt;/span&gt; ')
      result
    end

  end

end
</code></pre>

<h2>2. Layouts: tag_index.html</h2>

<pre><code class="bash">$ cp octopress/source/_layouts/category_index.html octopress/source/_layouts/tag_index.html
</code></pre>

<p>Update the <code>category</code> as <code>tag</code>.</p>

<h2>3. Config: tag_dir</h2>

<pre><code class="yml _config.yml">tag_dir: tags
</code></pre>

<h2>4. Testing</h2>

<p><code>rake generate</code> and <code>rake preview</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Adding Tag Cloud in Octopress]]></title>
    <link href="http://k.arttechresearch.com/tech/2015/10/06/adding-tag-cloud-in-octopress/"/>
    <updated>2015-10-06T05:20:09+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2015/10/06/adding-tag-cloud-in-octopress</id>
    <content type="html"><![CDATA[<p>Features: tag cloud and category list with counts.</p>

<p>Steps:</p>

<ol>
<li>update the ruby plugin: <code>plugins/tag_cloud.rb</code></li>
<li>update the html templates: <code>source/_includes/asides/tag_cloud.html</code>, <code>source/_includes/asides/category_list.html</code></li>
<li>update the sass files: <code>sass/plugins/_tag_cloud.scss</code>, <code>sass/plugins/_category_list.scss</code></li>
</ol>


<h2>1. Plugin: tag_cloud.rb</h2>

<pre><code class="ruby tag_cloud.rb"># encoding: utf-8

# Tag Cloud for Octopress
# =======================
#
# Description:
# ------------
# Easy output tag cloud and category list.
#
# Syntax:
# -------
#     {\% tag_cloud [counter:true] %\}
#     {\% category_list [counter:true] %\}
#
# Example:
# --------
# In some template files, you can add the following markups.
#
# ### source/_includes/custom/asides/tag_cloud.html ###
#
#     `&lt;section&gt;`
#       `&lt;h1&gt;Tag Cloud&lt;/h1&gt;`
#         `&lt;span id="tag-cloud"&gt;{\% tag_cloud %\}&lt;/span&gt;`
#     `&lt;/section&gt;`
#
# ### source/_includes/custom/asides/category_list.html ###
#
#     `&lt;section&gt;`
#       `&lt;h1&gt;Categories&lt;/h1&gt;`
#         `&lt;ul id="category-list"&gt;{\% category_list counter:true %\}&lt;/ul&gt;`
#     `&lt;/section&gt;`
#
# Notes:
# ------
# Be sure to insert above template files into `default_asides` array in `_config.yml`.
# And also you can define styles for 'tag-cloud' or 'category-list' in a `.scss` file.
# (ex: `sass/custom/_styles.scss`)
#
# Licence:
# --------
# Distributed under the [MIT License][MIT].
#
# [MIT]: http://www.opensource.org/licenses/mit-license.php
#
require 'stringex'

module Jekyll

  class TagCloud &lt; Liquid::Tag

    def initialize(tag_name, markup, tokens)
      @opts = {}
      if markup.strip =~ /\s*counter:(\w+)/i
        @opts['counter'] = ($1 == 'true')
        markup = markup.strip.sub(/counter:\w+/i,'')
      end
      super
    end

    def render(context)
      lists = {}
      max, min = 1, 1
      config = context.registers[:site].config
      tag_dir = config['root'] + config['tag_dir'] + '/'
      tags = context.registers[:site].tags
      tags.keys.sort_by{ |str| str.downcase }.each do |tag|
        count = tags[tag].count
        lists[tag] = count
        max = count if count &gt; max
      end

      html = ''
      lists.each do | tag, counter |
        url = tag_dir + tag.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').downcase
        style = "font-size: #{90 + (110 * Float(counter-1)/(max-1))}%"
        html &lt;&lt; "&lt;a href='#{url}' style='#{style}'&gt;#{tag}"
        if @opts['counter']
          html &lt;&lt; "(#{tags[tag].count})"
        end
        html &lt;&lt; "&lt;/a&gt; "
      end
      html
    end
  end

  class CategoryList &lt; Liquid::Tag

    def initialize(tag_name, markup, tokens)
      @opts = {}
      if markup.strip =~ /\s*counter:(\w+)/i
        @opts['counter'] = ($1 == 'true')
        markup = markup.strip.sub(/counter:\w+/i,'')
      end
      super
    end

    def render(context)
      html = ""
      config = context.registers[:site].config
      category_dir = config['category_dir']
      categories = context.registers[:site].categories
      categories.keys.sort_by{ |str| str.downcase }.each do |category|
        html &lt;&lt; "&lt;li&gt;&lt;a href='http://k.arttechresearch.com/#{category_dir}/#{category.to_url}/'&gt;#{category}"
        if @opts['counter']
          html &lt;&lt; " (#{categories[category].count})"
        end
        html &lt;&lt; "&lt;/a&gt;&lt;/li&gt;"
      end
      html
    end
  end

end

Liquid::Template.register_tag('tag_cloud', Jekyll::TagCloud)
Liquid::Template.register_tag('category_list', Jekyll::CategoryList)
</code></pre>

<h2>2. HTML: source/_includes/</h2>

<p>tag_cloud.html</p>

<pre><code class="html tag_cloud.html">&lt;section class="tag-cloud"&gt;
  &lt;h1&gt;Tags&lt;/h1&gt;
    &lt;ul id="category-list"&gt;{\% tag_cloud counter:true %\}&lt;/ul&gt;
&lt;/section&gt;
</code></pre>

<p>category_list.html</p>

<pre><code class="html category_list.html">&lt;section class="category-list"&gt;
  &lt;h1&gt;Summary&lt;/h1&gt;
    &lt;ul id="category-list"&gt;{\% category_list counter:true %\}&lt;/ul&gt;
&lt;/section&gt;
</code></pre>

<h2>3. SASS: sass/plugins</h2>

<p>_tag_cloud.scss</p>

<pre><code class="css _tag_cloud.scss">&lt;section class="category-list"&gt;
  &lt;h1&gt;Summary&lt;/h1&gt;
    &lt;ul id="category-list"&gt;<li><a href='/categories/art/'>art (1)</a></li><li><a href='/categories/life/'>life (45)</a></li><li><a href='/categories/tech/'>tech (74)</a></li>&lt;/ul&gt;
&lt;/section&gt;
kelly-2:octopress kelly$ cat sass/plugins/_tag_cloud.scss
.tag-cloud {
    ul {
        padding: .5em 0;
    }
    a {
    text-decoration: none;
    }
}
</code></pre>

<p>_category_list.scss</p>

<pre><code class="css _category_list.scss">.category-list {
    a {
    text-decoration: none;
    }
}
</code></pre>

<h2>4. Testing</h2>

<p>Include the <code>tag_cloud.html</code> and <code>category_list.html</code> in a page, and then run <code>rake generate</code> and <code>rake preview</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Adding the Social Icons in Octopress]]></title>
    <link href="http://k.arttechresearch.com/tech/2015/10/06/adding-the-social-icons-in-octopress/"/>
    <updated>2015-10-06T05:04:17+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2015/10/06/adding-the-social-icons-in-octopress</id>
    <content type="html"><![CDATA[<h2>1. Perfections: design the icons</h2>

<p>Go to <a href="http://perfecticons.com">Perfections</a>, choose the icons you need, select the styles, and then generate the codes.</p>

<p>Once done, download the <code>fonts.zip</code>.</p>

<h2>2. Octopress: integrate the icons</h2>

<ul>
<li>copy the <code>fonts.zip</code> to <code>octopress/source/assets/fonts/</code></li>
<li>copy the html file to <code>octopress/source/_includes/social.html</code>, and then modify the variables</li>
<li>add the <code>social.html</code> to a page</li>
<li>copy the css file to <code>octopress/sass/partials/_socials.scss</code></li>
<li>update the links in <code>octopress/_config.yml</code></li>
</ul>


<p>Once done, run <code>rake generate</code> and <code>rake preview</code> to check.</p>
]]></content>
  </entry>
  
</feed>
