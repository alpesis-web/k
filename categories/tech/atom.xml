<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | K]]></title>
  <link href="http://k.arttechresearch.com/categories/tech/atom.xml" rel="self"/>
  <link href="http://k.arttechresearch.com/"/>
  <updated>2016-03-28T16:21:14+08:00</updated>
  <id>http://k.arttechresearch.com/</id>
  <author>
    <name><![CDATA[K]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MongoDB Sharding]]></title>
    <link href="http://k.arttechresearch.com/tech/2016/03/24/mongodb-sharding/"/>
    <updated>2016-03-24T10:59:40+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2016/03/24/mongodb-sharding</id>
    <content type="html"><![CDATA[<h2>Definitions</h2>

<p>Sharding: sharding is a method for storing data across multiple machines.</p>

<p>Purpose of sharding</p>

<ul>
<li>high query rate -> CPU capacity of the server</li>
<li>larger data sets -> storage capacity of a single machine -> RAM stress, I/O capacity of disk drives</li>
</ul>


<p>Vertical scaling V.S. Sharding</p>

<ul>
<li>vertical scaling: adds more CPU and storage resources to increase capacity. Large numbers of CPUs and large amount of RAM, expensive systems</li>
<li>horizontal scaling (sharding): divides the data set and distributes the data over multiple servers or shards. Each shard is an independent database, and collectively, the shards make up a single logical database.</li>
</ul>


<p>Advantages of sharding:</p>

<ul>
<li>sharding reduces the number of operations each shard handles. Each shard processes fewer operations as the cluster grows. As a result, a cluster can increase capacity and throughput horizontally. For example, to insert data, the application only needs to access the shard responsible for that record.</li>
<li>sharding reduces the amount of data that each server needs to store. Each shard stores less data as the cluster grows. For example, if a database has a 1 terabyte data set, and there are 4 shards, then each shard might hold only 256 GB of data. If there are 40 shards, then each shard might hold only 25GB of data.</li>
</ul>


<p><img src="https://docs.mongodb.org/manual/_images/sharded-collection.png" /></p>

<p>image source: MongoDB official site</p>

<h2>Concepts</h2>

<h3>Shared Clusters</h3>

<ul>
<li>Shards: store the data. To provide high availability and data consistency, in a production sharded cluster, each shard is a replica set.</li>
<li>Query Routers (mongos instances): interface with client applications and direct operations to the appropriate shard or shards. A client sends requests to a mongos, which then routes the operations to the shards and returns the results to the clients. A sharded cluster can contain more than one mongos to divide the client request load, and most sharded clusters have more than one mongos for this reason.</li>
<li>Config Servers: store the cluster&rsquo;s metadata. This data contains a mapping of the clusters&rsquo;s data set to the shards. The query router uses this metadata to target operations to specific shards.</li>
</ul>


<p><img src="https://docs.mongodb.org/manual/_images/sharded-cluster.png" /></p>

<p>image source: MongoDB official site</p>

<h3>Shards: Data Partitioning</h3>

<p>MongoDB distributes data, or shards, at the collection level. Sharding partitions a collection&rsquo;s data by the shard key.</p>

<ul>
<li>Shard key: A shard key is either an indexed field or an indexed compound field that exists in every document in the collection. {key: value} &ndash;> chunks (ranged/hash based partitioning)</li>
<li>ranged based sharding: documents with &ldquo;close&rdquo; shard key values are likely to be in the same chuck, and therefore on the same shard. The query router can easily determine which chunks overlap that range and route the query to only those shards that contain these chunks.</li>
<li>hash based sharding: two documents with &ldquo;close&rdquo; shard key values are unlikely to be part of the same chuck. This ensures a more random distribution of a collection in the cluster. Hash key values results in random distribution of data across chunks and therefore shards. But random distribution makes it more likely that a range query on the shard key will not be able to target a few shards but would more likely query every shard in order to return a result.</li>
</ul>


<p><img src="https://docs.mongodb.org/manual/_images/sharding-range-based.png" /></p>

<p>image source: MongoDB official site</p>

<p><img src="https://docs.mongodb.org/manual/_images/sharding-hash-based.png" /></p>

<p>image source: MongoDB official site</p>

<h3>Config Servers: Balanced Data Distribution</h3>

<ul>
<li>splitting: splitting is a background process that keeps chunks from growing too large. When a chunk grows beyond a specified chunk size, MongoDB splits the chunk in half. Inserts and updates triggers splits. Splits are an efficient meta-data change. To create splits, MongoDB does not migrate any data or affect eh shards.</li>
<li>balancer: the balancer is a background process that manages chunk migrations. The balancer can run from any of the mongos instances in a cluster. For example, if collection users has 100 chunks on shard 1 and 50 chunks on shard 2, the balancer will migrate chunks from shard 1 to shard 2 until the collection achieves balance.</li>
</ul>


<p><img src="https://docs.mongodb.org/manual/_images/sharding-splitting.png" /></p>

<p>image source: MongoDB official site</p>

<p><img src="https://docs.mongodb.org/manual/_images/sharding-migrating.png" /></p>

<p>image source: MongoDB official site</p>

<h3>Query Routers: Query Routing</h3>

<p>Routing process</p>

<ul>
<li>(mongos -> shards)</li>
</ul>


<pre><code>shard key:

{ zipcode: 1, u_id: 1, c_date: 1 }

targeting:

{ zipcode: 1 }
{ zipcode: 1, u_id: 1 }
{ zipcode: 1, u_id: 1, c_date: 1 }
</code></pre>

<p>detect connection</p>

<pre><code>db.isMaster()

{
   "ismaster" : true,
   "msg" : "isdbgrid",
   "maxBsonObjectSize" : 16777216,
   "ok" : 1
}
</code></pre>

<p>broadcast operations and targeted operations</p>

<p><img src="https://docs.mongodb.org/manual/_images/sharded-cluster-scatter-gather-query.png" /></p>

<p>image source: MongoDB official site</p>

<p><img src="https://docs.mongodb.org/manual/_images/sharded-cluster-targeted-query.png" /></p>

<p>image source: MongoDB official site</p>

<p>shared and non-shared data</p>

<p><img src="https://docs.mongodb.org/manual/_images/sharded-cluster-mixed.png" /></p>

<p>image source: MongoDB official site</p>

<h2>Tutorials</h2>

<h3>Deployment</h3>

<h3>Maintenance</h3>

<h3>Management</h3>

<h2>Reference</h2>

<ul>
<li><a href="https://docs.mongodb.org/manual/core/sharding-introduction/">Sharding</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MongoDB Replication]]></title>
    <link href="http://k.arttechresearch.com/tech/2016/03/24/mongodb-replication/"/>
    <updated>2016-03-24T10:59:23+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2016/03/24/mongodb-replication</id>
    <content type="html"><![CDATA[<h2>Definitions</h2>

<p>Replication is the process of synchronizing data across multiple servers.</p>

<p>Purposes of replication</p>

<ul>
<li>provides redundancy and increases data availability. With multiple copies of data on different database servers, replication provides a level of fault tolerance against the loss of a signle database server.</li>
<li>provides increased read capacity as clients can send read operations to different servers. Maintaining copies of data in different data centers can increase data locality and availability for distributed applications.</li>
<li>dedicated purposes, such as disaster recovery, reporting, or backup.</li>
</ul>


<h2>Concepts</h2>

<h3>Replica Set: Members</h3>

<h3>Replica Set: Deployment Architectures</h3>

<h3>Replica Set: High Availability</h3>

<h3>Replica Set: Read and Write Senmantics</h3>

<p><img src="https://docs.mongodb.org/manual/_images/crud-write-concern-w2.png" /></p>

<p>image source: MongoDB official site</p>

<p><img src="https://docs.mongodb.org/manual/_images/replica-set-read-preference.png" /></p>

<p>image source: MongoDB official site</p>

<h3>Replication Processes</h3>

<h3>Master Slave Replication</h3>

<h2>Tutorials</h2>

<h2>Reference</h2>

<ul>
<li><a href="https://docs.mongodb.org/manual/core/replication-introduction/">Replication</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MongoDB Security]]></title>
    <link href="http://k.arttechresearch.com/tech/2016/03/24/mongodb-security/"/>
    <updated>2016-03-24T10:59:17+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2016/03/24/mongodb-security</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MongoDB Storage]]></title>
    <link href="http://k.arttechresearch.com/tech/2016/03/24/mongodb-storage/"/>
    <updated>2016-03-24T10:59:08+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2016/03/24/mongodb-storage</id>
    <content type="html"><![CDATA[<h2>Definitions</h2>

<ul>
<li>storage engine: the primary component of MongoDB responsible for managing data.</li>
<li>journal: a log that helps the database recover in the event of a hard shutdown.</li>
<li>GridFS: a versatile storage system that is suited to handling large files, such as those exceeding the 16 MB document size limit.</li>
</ul>


<h2>Concepts</h2>

<h3>Storage Engine</h3>

<ul>
<li>WiredTiger: the default storage engine. It is well-suited for most workloads and is recommended for new deployments. WiredTiger provides a document-level concurrency model, checkpointing, and compression, among other features.</li>
<li>MMAPv1: the original storage engine. It performs well on workloads with high volumes of reads and writes, as well as in-place updates.</li>
<li>In-Memory Storage Engine: rather than storing documents on-disk, it retains them in-memory for more predictable data latencies. This storage engine is in beta.</li>
</ul>


<h3>Journal</h3>

<h3>GridFS</h3>

<h2>Tutorials</h2>

<h2>Reference</h2>

<ul>
<li><a href="https://docs.mongodb.org/manual/storage/">Storage</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MongoDB Indexes]]></title>
    <link href="http://k.arttechresearch.com/tech/2016/03/24/mongodb-indexes/"/>
    <updated>2016-03-24T10:59:00+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2016/03/24/mongodb-indexes</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
