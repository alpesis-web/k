<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | K]]></title>
  <link href="http://k.arttechresearch.com/categories/tech/atom.xml" rel="self"/>
  <link href="http://k.arttechresearch.com/"/>
  <updated>2015-11-08T04:18:06+08:00</updated>
  <id>http://k.arttechresearch.com/</id>
  <author>
    <name><![CDATA[K]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Challenge L3]]></title>
    <link href="http://k.arttechresearch.com/tech/2015/11/07/python-challenge-l3/"/>
    <updated>2015-11-07T20:35:25+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2015/11/07/python-challenge-l3</id>
    <content type="html"><![CDATA[<p><a href="">Python Challenge</a></p>

<h2>L3. Equality</h2>

<p><a href="http://www.pythonchallenge.com/pc/def/equality.html">L3</a></p>

<p>One small letter, surrounded by EXACTLY three big bodyguards on each of its
sides.</p>

<pre><code class="python equality.py">import re

def search_equality(text):
    """ Return the letter if that matches the pattern, else return None
    """

    # pattern: [1 lower](3 uppers)[1 lower](3 uppers)[1 lower], e.g.: aBBDiLDMx
    pattern = "[a-z][A-Z][A-Z][A-Z][a-z][A-Z][A-Z][A-Z][a-z]"
    equality = re.search(pattern, text)
    if equality:
        # just return the lowercase on the position 5 (index[4])
        return equality.group()[4]
    else:
        return None

if __name__ == '__main__':

    text_path = "./data/3_equality.txt"

    equalities = []
    text = open(text_path, 'r')
    for line in text.readlines():
        # search the letters those matching the patterns
        equality = search_equality(line.strip())
        # just append the valid letters, None exclusive
        equalities.append(equality) if equality is not None else equalities
    text.close()

    print ''.join(letter for letter in equalities)
</code></pre>

<p>output</p>

<pre><code class="python equality ouptut">linkedlist
</code></pre>

<p>Update the url with <code>linkedlist</code>, then jump to a new page with <code>linkedlist.php</code>,
update the url with <code>linkedlist.php</code>, then jump to L4.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Configurating Colortheme for iTerm]]></title>
    <link href="http://k.arttechresearch.com/tech/2015/11/05/configurating-colortheme-for-iterm/"/>
    <updated>2015-11-05T23:08:34+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2015/11/05/configurating-colortheme-for-iterm</id>
    <content type="html"><![CDATA[<p>The colortheme files of iTerm is <code>*.itermcolors</code>, everyone can create or update a colortheme and
then import it to iTerm. Alternatively, you can download the colorthemes which are shared in
public and then update them in iTerm.</p>

<p>If Vim is set as the editor, it would be better to keep the colortheme as the same as iTerm.</p>

<h2>1. Colorthemes</h2>

<pre><code class="bash">$ git clone git://github.com/altercation/solarized.git
$ git clone https://github.com/mbadolato/iTerm2-Color-Schemes.git
</code></pre>

<h2>2. iTerm</h2>

<ul>
<li>iTerm -> Preferences -> Profiles -> Colors -> Load Presets -> import</li>
</ul>


<p>import the colorthemes</p>

<ul>
<li>if solarized: iterm2-colors-soloarized</li>
<li>if iTerm2-Color-Schemes: <code>*.itermcolors</code></li>
</ul>


<h2>3. .bash_profile</h2>

<pre><code class="bash">$ brew install coreutils
$ vim ~/.bash_profile             # add export clicolor
$ source ~/.bash_profile
</code></pre>

<p>.bash_profile</p>

<pre><code class="bash">export CLICOLOR=1
</code></pre>

<p>Preview</p>

<p><img src="https://s-media-cache-ak0.pinimg.com/736x/d7/ba/d3/d7bad3e5432d03d2330b88f49dc4b488.jpg" /></p>

<h2>4. vim</h2>

<pre><code class="bash"># copy the colorscheme
$ mkdir ~/.vim/colors
$ cd ~/.vim/colors
$ cp /path/to/solarized/vim-colors-solarized/colors/solarized.vim ./

# update the .vimrc
$ vim ~/.vimrc
</code></pre>

<p>.vimrc</p>

<pre><code class="bash">syntax enable
set background=dark
colorscheme solarized
</code></pre>

<p>Preview</p>

<p><img src="https://s-media-cache-ak0.pinimg.com/736x/31/f1/93/31f19309e06e9affcd25b81f0b8ddc06.jpg" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Challenge L0-L2]]></title>
    <link href="http://k.arttechresearch.com/tech/2015/11/05/python-challenge-l0-l2/"/>
    <updated>2015-11-05T16:07:22+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2015/11/05/python-challenge-l0-l2</id>
    <content type="html"><![CDATA[<p><a href="http://www.pythonchallenge.com">Python Challenge</a></p>

<h2>L0</h2>

<p><a href="http://www.pythonchallenge.com/pc/def/0.html">L0</a></p>

<p>Hint: try to change the URL address.</p>

<pre><code class="python">&gt;&gt;&gt; 2**38
274877906944
</code></pre>

<p>Update the url.</p>

<h2>L1. Map</h2>

<p><a href="http://www.pythonchallenge.com/pc/def/map.html">L1</a></p>

<p>everybody thinks twice before solving this.</p>

<p>solution</p>

<pre><code class="python map.py">from string import maketrans

alphabet = "abcdefghijklmnopqrstuvwxyz"
alphabet_decode = "cdefghijklmnopqrstuvwxyzab"
map_table = maketrans(alphabet, alphabet_decode)


if __name__ == '__main__':

    strings = """
    g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.
    """

    url = "map"

    print strings.translate(map_table)
    print url.translate(map_table)
</code></pre>

<p>result</p>

<pre><code class="python map outputs">    i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that's why this text is so long. using string.maketrans() is recommended. now apply on the url.

ocr
</code></pre>

<p>Then update the url with <code>ocr</code>.</p>

<h2>L2. OCR</h2>

<p><a href="http://www.pythonchallenge.com/pc/def/ocr.html">L2</a></p>

<p>recognize the characters. maybe they are in the book,
but MAYBE they are in the page source.</p>

<pre><code class="python ocr.py"># dictionary: http://www.math.sjsu.edu/~foster/dictionary.txt
# download the dictionary for mapping the words

def print_sorted_keys(dictionary):
    print sorted(dictionary.items(), key=lambda dictionary: dictionary[0])

def print_sorted_values(dictionary):
    print sorted(dictionary.items(), key=lambda dictionary: dictionary[1])

def generate_word_dict(file_path):

    word_counts = {}

    text = open(file_path, 'r')
    for line in text.readlines():
        for char in line:
            if char not in word_counts.keys():
                word_counts[char] = 1
            else:
                word_counts[char] += 1
    text.close()

    return word_counts

def mapping(letters, dictbook):

    words = []

    dictbook = open(dictbook, 'r')
    for line in dictbook.readlines():
        # if set(line.strip()) == set(letters):
        #     words.append(line.strip())
        words.append(line.strip()) if set(line.strip()) == set(letters) else words
    dictbook.close()

    return words

if __name__ == '__main__':

    file_path = './data/2_ocr.txt'
    dictbook = "./data/dictionary.txt"

    # find the letters
    word_counts = generate_word_dict(file_path)
    print_sorted_keys(word_counts)
    print_sorted_values(word_counts)

    # look for a word from a dictionary
    letters = "aeilquty"
    words = mapping(letters, dictbook)
    print words
</code></pre>

<p>result</p>

<pre><code class="python ocr outputs">[('a', 1), ('e', 1), ('i', 1), ('l', 1), ('q', 1), ('u', 1), ('t', 1), ('y', 1), ('\n', 1220), ('^', 6030), ('*', 6034), ('&amp;', 6043), ('$', 6046), ('{', 6046), ('+', 6066), ('!', 6079), ('%', 6104), ('}', 6105), ('[', 6108), ('_', 6112), ('#', 6115), (']', 6152), ('(', 6154), ('@', 6157), (')', 6186)]
['equality']
</code></pre>

<p>Update the url with <code>equality</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Converting Markdown to PDF With NodeJS]]></title>
    <link href="http://k.arttechresearch.com/tech/2015/10/21/converting-markdown-to-pdf-with-nodejs/"/>
    <updated>2015-10-21T19:57:50+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2015/10/21/converting-markdown-to-pdf-with-nodejs</id>
    <content type="html"><![CDATA[<h2>Requirements</h2>

<ul>
<li>OS: OS X</li>
<li>Language: Node.js/npm</li>
<li>Dependency: markdown-pdf</li>
</ul>


<h2>Example</h2>

<p>install dependency</p>

<pre><code class="bash">$ npm install markdown-pdf
</code></pre>

<p>convert markdown to pdf</p>

<pre><code class="javascript md2pdf.js">var md_file = "./file_name.md"
var output_file = "./outputs/file_name.pdf"

var markdownpdf = require("markdown-pdf")
var fs = require("fs")

fs.createReadStream(md_file)
  .pipe(markdownpdf())
  .pipe(fs.createWriteStream(output_file))
</code></pre>

<p>testing</p>

<pre><code class="bash">$ node md2pdf.js
</code></pre>

<h2>Reference</h2>

<ul>
<li><a href="https://www.npmjs.com/package/markdown-pdf">markdown-pdf</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Summary on edX Devkits]]></title>
    <link href="http://k.arttechresearch.com/tech/2015/10/19/summary-on-edx-devkits/"/>
    <updated>2015-10-19T14:13:04+08:00</updated>
    <id>http://k.arttechresearch.com/tech/2015/10/19/summary-on-edx-devkits</id>
    <content type="html"><![CDATA[<ul>
<li>edX Platform</li>
<li>edX Analytics</li>
<li>edX Certificates</li>
<li>edX eCommerce</li>
<li>edX Mobiles</li>
<li>edX Ansible</li>
<li>Devkits</li>
</ul>


<h2>1. edX Platform</h2>

<p>sub-projects</p>

<ul>
<li>edx-platform</li>
<li>forum / cs_comments_service</li>
<li>hipchat</li>
<li>ora</li>
<li>xblock</li>
</ul>


<p>toolkits</p>

<ul>
<li>backend: Python/Django, Ruby</li>
<li>frontend: Node.js</li>
</ul>


<p>techniques</p>

<ul>
<li>OAuth2.0</li>
<li>RESTful API</li>
<li>ElasticSearch</li>
</ul>


<h2>2. edX Analytics</h2>

<p>sub-projects</p>

<ul>
<li>edx-analytics-pipeline</li>
<li>edx-analytics-data-api</li>
<li>edx-analytics-data-api-client</li>
<li>edx-analytics-dashboard</li>
</ul>


<p>toolkits:</p>

<ul>
<li>backend: Python/Django</li>
<li>frontend: Node.js</li>
</ul>


<p>techniques</p>

<ul>
<li>Hadoop</li>
<li>HDFS</li>
<li>MapReduce / Yarn</li>
<li>Hive</li>
<li>Sqoop</li>
<li>Python/Luigi</li>
</ul>


<h2>3. edX Certificates</h2>

<p>sub-projects</p>

<ul>
<li>edx-certs</li>
<li>xqueue</li>
<li>xqwatcher</li>
<li>xqwatcher-client</li>
</ul>


<p>toolkits</p>

<ul>
<li>backend: Python/Django</li>
<li>frontend: Node.js</li>
</ul>


<p>techniques</p>

<ul>
<li>RabbitMQ</li>
</ul>


<h2>4. edX eCommerce</h2>

<h2>5. edX Mobiles</h2>

<ul>
<li>ios</li>
<li>android</li>
</ul>


<h2>6. edX Ansible</h2>

<ul>
<li>ansible</li>
<li>openstack / aws</li>
</ul>


<h2>Devkits</h2>

<ul>
<li>IDE: PyCharm</li>
<li>DBs: MySQL, MongoDB</li>
</ul>

]]></content>
  </entry>
  
</feed>
